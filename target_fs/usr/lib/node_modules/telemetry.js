(function (network, request) {

class telemetryClient {

    constructor (conf) {
        this.config = conf;
        this.onddClient = null;
        this.items = this.config.items;

        this.augments = {
            "version" : process.env.RXOS_VERSION,
            "platform" : process.env.RXOS_SUBPLATFORM,
            "count"   : 1
        };

        this.aggregators = {
            "avg": {
                "init" : () => { return { "sum": 0, "count": 0}; },
                "update" : (previous, value) => { return { "sum": previous.sum + value, "count": previous.count + 1}; },
                "get" : (state) => { return (state.sum / state.count); }
            },
            "last": {
                "init" : () => { return null; },
                "update" : (previous, value) => { return value; },
                "get" : (state) => { return state; }
            },
            "hist": {
                "init" : () => { return {}; },
                "update" : (previous, value) => {
                     if (!previous[value])
                        previous[value] = 0;
                     previous[value] += 1;
                     return previous;
                 },
                "get" : (state) => { return state; }
            },
            "sum": {
                "init" : () => { return 0; },
                "update" : (previous, value) => { return previous + value; },
                "get" : (state) => { return state; }
            }
        };

        this.ticker = 0;
        this.aggregates = {};
    }


    attachOnddClient(ondd) {
        this.onddClient = ondd;
    }

    aggregateInit() {
        Object.keys(this.items).map ((v) => {
            this.aggregates[v] = (this.aggregators[this.items[v]]).init();
        });
    }

    aggregateUpdate(values) {
        var c = {};
        Object.assign(c, values, this.augments);
        Object.keys(this.items).map ( (v) => {
            this.aggregates[v] = (this.aggregators[this.items[v]]).update(this.aggregates[v], c[v]);
        });
    }

    aggregateGet() {
        var c = {};
        Object.keys(this.items).map ( (v) => {
            c[v] = (this.aggregators[this.items[v]]).get(this.aggregates[v]);
        });
        c = JSON.parse(JSON.stringify(c)); // simply a hack for deep copy.
        this.aggregateInit(); // clear the data
        return c;
    }

    getNetworkInfo(iface, cb) {
        network.get_interfaces_list(function(err, list) {
            list.forEach( function(i) {
                if(i.name == iface) {
                    cb( {
                        "macid" : i.mac_address,
                        "lanip" : i.ip_address,
                        "uptime": process.uptime()
                    });
                }
            });
        });
    }

    send(values) {
        this.getNetworkInfo(this.config.idInterface, (function(netInfo) {
            Object.assign(values, netInfo);
            try {
                request({
                    url: this.config.endPoint,
                    qs: values,
                    method: 'GET',
                    rejectUnauthorized: false,
                    headers: {
                        'User-Agent': this.config.userAgent
                    }
                });
            } catch (err) {} // ignore errors
        }).bind(this));
    }

    update() {
        this.ticker += 1;
        this.aggregateUpdate(this.onddClient.getStatus());
        if (this.ticker >= this.config.reportingInterval) {
            this.ticker = 0;
            this.send(this.aggregateGet());
        }
    }

    start() {
        this.aggregateInit();
        this.ticker = this.config.reportingInterval - 30; // send one update 30 seconds after restart
        this.innerLoop = setInterval( this.update.bind(this), this.config.collectionInterval);
    }
}

module.exports.client = telemetryClient;

}) (require('network'), require('request'));
